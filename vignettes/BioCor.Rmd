---
title: "BioCor"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('BioCor')`"
abstract: >
  Vignette of BioCor package
output:
  BiocStyle::pdf_document2:
    fig_caption: yes
    toc: yes
    toc_depth: 3
  BiocStyle::html_document2:
    fig_caption: yes
    toc_float: yes
    toc_depth: 3
author:
  name: Lluís Revilla
  affiliation: 
  - IDIBAPS 
  - Liver Unit, Hospital Clinic
  email: lrevilla@clinic.cat
vignette: >
  %\VignetteIndexEntry{BioCor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
```{r knitsetup, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = ".")
knitr::opts_chunk$set(fig.width = 20, fig.height = 10, collapse = TRUE)
BiocStyle::markdown()
```


# Introduction

Methods to find similarities have been developed for several purposes, being Jaccard and Dice similarities the most known. In bioinformatics much of the research on the topic centered on Gene Ontologies partially because there is a known structure and has a controlled vocabulary. Several methods of calculating similarities using Gene Ontologies are available at `r BiocStyle::Biocpkg("GOSemSim")`.

However, there is another resource of similarities between genes: metabolic pathways. Metabolic pathways describe the relationship between genes, proteins, fats and other elements of the cells. A pathway describes, to some extent, the function in which it is involved in the cell. There exists several databases about which gene belong to which pathway. With this package we provide the methods to calculate similarities based on this information.

Here we provides functions to calculate similarities for pathways, genes and clusters of genes. As it development started aiming to group better genes by functionality in co-expression networks using *[WGCNA](https://cran.r-project.org/package=WGCNA)*.

# Citation
The main article describing how it has been applied, is currently under writing.

# Installation
The BioCor package will be available at bioconductor.org and will be downloaded and installed via biocLite:
```{r install, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("BioCor")
```

You can install the latest version of `r BiocStyle::Githubpkg("llrs/BioCor")` from Github with:
```{r github, eval = FALSE}
library("devtools")
install_github("llrs/BioCor")
```

# Using BioCor

## Preparation

We can load the package and prepare the data for which we want to calculate the similarities:
```{r load}
library("BioCor")
# Load libraries with the data of the pathways
library("org.Hs.eg.db")
library("reactome.db")
# Prepare the data
genes.kegg <- as.list(org.Hs.egPATH)
genes.react <- as.list(reactomeEXTID2PATHID)
```

To avoid having biased data it is important to have all the data about the pathways and genes associated to all pathways for organism under study. Here we assume that we are interested in human pathways. We use this two databases KEGG and Reactome as they are easy to obtain the data. However KEGG database is no longer free for large retrievals therefore it is not longer updated in the Bioconductor annotation packages.


## Pathway similarities

We can compute similarities between two pathways or between several pathways and combine them, or not:
```{r pathSim}
pathSim("112310", "1500931", genes.react)

pathways <- c("112310", "112315", "112316", "373753", "916853", "109582", 
              "114608")
mpathSim(pathways, genes.react, NULL)
```
In row-wise we have the pathways of the first argument and column-wise the pathways of the second argument.

### Combining values {#combining}
To combine values we provide a function with several methods:
```{r combineScores}
sim <- mpathSim(pathways, genes.react, NULL)
methodsCombineScores <- c("avg", "max", "rcmax", "rcmax.avg", "BMA")
sapply(methodsCombineScores, combineScores, scores = sim)
```
We can also specify the method to combine the similarities in `pathSim`, `mpathSim`, `geneSim`, `mgeneSim`, `clusterSim`, `mclusterSim`, `clusterGeneSim` and `mclusterGeneSim`, argument method, by default it is the "max" method to combine pathways and BMA to combine similarities of genes or for cluster analysis. This function is adapted from GOSemSim package.

## Gene similarities {#geneSim}
To calculate a single pair of comparisons there are the `geneSim` and `mgeneSim` function for several comparisons. In this example we compare the genes BRCA1 and BRCA2 and NAT2:
```{r geneSim}
geneSim("672", "675", genes.kegg)
geneSim("672", "675", genes.react)

mgeneSim(c("672", "675", "10"), genes.kegg)
mgeneSim(c("672", "675", "10"), genes.react)
```

Note that for the same genes each database has different annotations, which result on different similarity scores. In this example the gene 672 has `r ncol(geneSim("672", "675", genes.kegg, NULL))` and `r ncol(geneSim("672", "675", genes.react, NULL))` pathways in KEGG and Reactome respectively and the gene 675 has `r nrow(geneSim("672", "675", genes.kegg, NULL))` and `r nrow(geneSim("672", "675", genes.react, NULL))` pathways in KEGG and Reactome respectively which results on different scores.

## Gene cluster similarities

There are two methods:

* Combining all the pathways for each cluster and compare between them.
* Calculate the similarity between genes of a cluster and the other cluster.

### By pathways similarities {#clusterSim}

If a method to combine pathways similarities is not provided all pathway similarities are returned:
```{r clusterSim}
clusterSim(c("672", "675"), c("100", "10", "1"), genes.kegg)
clusterSim(c("672", "675"), c("100", "10", "1"), genes.kegg, NULL)

clusters <- list(cluster1 = c("672", "675"),
                 cluster2 = c("100", "10", "1"),
                 cluster3 = c("18", "10", "83"))
mclusterSim(clusters, genes.kegg, "rcmax.avg")
```

### By genes similarities {#clusterGeneSim}

In this method we need to specify two methods to combine values, the first one to combine pathway similarities for each gene, the second to combine gene similarities for each cluster. If only one is provided it returns the matrix of similarities of the genes of each cluster:
```{r clusterGeneSim}
clusterGeneSim(c("672", "675"), c("100", "10", "1"), genes.kegg)
clusterGeneSim(c("672", "675"), c("100", "10", "1"), genes.kegg, "max")

mclusterGeneSim(clusters, genes.kegg, c("max", "rcmax.avg"))
```

Note the differences between each method in the similarity values of the clusters.

## Merging similarities {#merging}
If one calculate similarities for with KEGG data and Reactome or other input for the same genes or clusters we provide a couple of functions to merge them:

We can set a weight to each similarity input with `weighted.sum`, multiply them but using also a weight for each, doing the mean or just adding them up
```{r merging}
kegg <- mgeneSim(c("672", "675", "10"), genes.kegg)
react <- mgeneSim(c("672", "675", "10"), genes.react)
# We can sum it adding a weight to each origin
weighted.sum(c(kegg["672", "675"], react["672","675"]), w = c(0.3, 0.7))

# Or if we want to perform for all the matrix
# A list of matrices to merge
sim <- list("kegg" = kegg, "react" = react)
similarities(sim, weighted.sum, w = c(0.3, 0.7))
similarities(sim, weighted.prod, w = c(0.3, 0.7))
similarities(sim, prod)
similarities(sim, mean)
```

# High volumes of gene similarities
We can compute the whole similarity of genes in KEGG or Reactome by using :
```{r whole_db, eval=FALSE}
# Omit those genes without a pathway
nas <- sapply(gene.kegg, function(y){all(is.na(y))})
gene.kegg2 <- gene.kegg[!nas]
m <- mgeneSim(names(gene.kegg2), gene.kegg2, method  = NULL)
```
It takes around 5 hours in one core but it requires high memory available.

Then it can be used to fit with other matrix with
```{r whole_db2, eval=FALSE}
sim <- AintoB(m, B)
```
Where B is a symmetric matrix of the size our genes * genes.

# An example of usage

In this example I show how to use BioCor to analyse a list of genes by functionality. 

With a list of genes we are going to see how similar are those genes:

```{r hclust1, fig.cap="Gene clustering by similarities"}
genes.id <- c("10", "15", "16", "18", "2", "9", "52", "3855", "3880", "644", 
              "81327", "9128", "2073", "2893", "5142", "60", "210", "81", 
              "1352", "88", "672", "675")
react <- mgeneSim(genes.id, genes.react)
# We remove colums with too much NA
nas <- apply(react, 1, function(x){sum(is.na(x))})
react <- react[nas <= 10, nas <= 10]
plot(hclust(as.dist(1 - react)))
```
As we can see there is a gene which is not related to others in the list (the 81). We can explore why by looking at the name

```{r hclust2, tidy=TRUE} 
info <- select(org.Hs.eg.db, keys = genes.id, keytype = "ENTREZID",
       columns = c("SYMBOL", "GENENAME"))
info
```

We can see now that the gene 2073 is the ERCC5 related with BRCA1 and BRCA2, as the name indicates all three are linked to DNA. We can also observe that the actinin alpha 4 and 2 are involved in different functions, and there is a pair of genes related to RNA, another group is not clear what functions do they do. Two groups are related to metabolism one about acetil metabolism and another more general.

We can group them for a cluster analysis to visualize the relationship between the clusters:

```{r hclust3, fig.cap="Clustering using clusterSim"}
clusters <- list(DNA = c("672", "675", "2073"),
                 RNA = c("16", "9128"),
                 acetil_metabolism = c("10", "15", "9", "644", "210", "1352"),
                 metabolism = c("18", "2893", "88"), 
                 unknown = c("2", "81327", "5142", "60"))
# Remember we can use both methods to compare clusters
sim_clus1 <- mclusterSim(clusters, genes.react)
plot(hclust(as.dist(1 - sim_clus1)))
```

```{r hclust3b, fig.cap="Clustering using clusterGeneSim"}
sim_clus2 <- mclusterGeneSim(clusters, genes.react)
plot(hclust(as.dist(1 - sim_clus2)))
```

Each method results in a different dendrogram as we can see  on Figure \@ref(fig:hclust3) compared to \@ref(fig:hclust3b), but the second is more accurate to describe the relationships between the genes in the clusters.

# WGCNA and BioCor 

[WGCNA](https://cran.r-project.org/package=WGCNA) uses the correlation of the expression data of several samples to cluster genes. From a biological point of view the interpretation of the resulting groups is difficult. Even more when some groups of genes end up not having an enrichment in described functions. BioCor was originally thought to be used to overcome this problem: to help clustering genes, not only by correlation but also by functionality. 

In order to have groups functionally related, functional similarities can enhance the clustering of genes when combined (See [this section](#merging)) with experimental correlations. The resulting groups will reflect, not only the correlation of the expression provided, but also the functionality known of those genes.

We propose the following steps:

1. Calculate the similarities for the expression data 
2. Calculate the similarities of the genes in the expression 
3. Join the similarities and use them to calculate the adjacency (`adjacency.fromSimilarity(similarity)`)
4. Identify modules with hierarchical clustering

Here we provide an example on how to use BioCor with WGCNA:

`sim` is a list where each element is a matrix of similarities between genes 
Our normalized expression data in the file *expression.RData* in the `expr` variable: a matrix where the samples are in the rows and genes at the columns.

```{r wgcna1, eval=FALSE}
# Load the expression data (see tutorial 1 of WGCNA)
load("expression.RData", verbose = TRUE)
expr.sim <- WGCNA::cor(expr) # or bicor

# Combine the similarities
similarity <- similarities(c(list(exp = expr.sim), sim), mean)

# Choose the softThreshold
pSFT <- pickSoftThreshold.fromSimilarity(similarity)

# Or any other function we want
adjacency <- adjacency.fromSimilarity(similarity, power = pSFT$powerEstimate)

# Once we have the similarities we can calculate the TOM with TOM
TOM <- TOMsimilarity(adjacency)
dissTOM <- 1 - TOM
geneTree <- hclust(as.dist(dissTOM), method = "average")
# We can use a clustering tool to group the genes
dynamicMods <- cutreeHybrid(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = 30)
moduleColors <- labels2colors(dynamicMods$labels) 
```

We can also use the functional similarities after calculating the adjacency:

```{r wgcna2, eval=FALSE}
# Load the expression data see tutorial 1 of WGCNA
load("expression.RData", verbose = TRUE)
# set the power necessary for a scale free topology based only in the expression
expr.adj <- adjacency(expr) 

# To combine the similarities either weighted.sum :
similarity <- similarities(c(list(exp = expr.adj), sim), 
                           weighted.sum, w = c(0.8, 0.1, 0.1))
# Or the mean
similarity <- similarities(c(list(exp = expr.sim), sim), mean) 
# Or any other function we want

# Once we have the similarities we can calculate the TOM with TOM
TOM <- TOMsimilarity(similarity)
dissTOM <- 1 - TOM
geneTree <- hclust(as.dist(dissTOM), method = "average")
# We can use a clustering tool to group the genes
dynamicMods <- cutreeHybrid(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = 30)
moduleColors <- labels2colors(dynamicMods$labels) 
```
Once the modules are identified using the functional similarities of this package and the gene correlations, one can continue with the workflow of WGCNA.

The critical point of this process is deciding how to combine the similarities and the expression data: 
 - If the functional similarities play a huge role, we will end up having only those genes closely related to the same functions. 
 - If the functional similarities play a low role, it will be similarly to only use WGCNA, and the genes won't be functionally related.
 
To choose how to select a combine method, we propose the following rules, build several networks with different combinations and pick the one which produces more groups or whose modules are more randomly related or where the 0 module or the grey module has the least number of genes. 

# FAQ

## How do you calculate how similar are two pathways ?
It uses the [Sørensen–Dice index](https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient): 
It is the double of the genes shared by the pathways divided by the number of genes in each pathway.

We can calculate the similarity between two pathways ($x$, $w$) with:

$$Dice(x, w) = \frac{2 |x \cap w|}{|x| + |w|}$$

This is implemented in the `diceSim` function, which results is similar to Jaccard index:

$$Jaccard(x, w) = \frac{|x \cap w|}{|x \cup w|}$$

Both Jaccard index and Dice index are between 0 and 1 ($[0, 1]$). To calculate the Jaccard index from the `diceSim` use the `D2J` function.

## Why do you use the dice coefficient and not the Jaccard ?
We consider Dice coefficient better than Jaccard because it has higher values for the same comparisons. Also to include a gene in a pathway is difficult and it is a way to reward the known interactions. 

## How do you combine similarities between several pathways of two genes?
Although the recommend method is the "max" method, (set as default), there are implemented other methods in `combineScores` of the `r BiocStyle::Biocpkg("GOSemSim")` package which I borrowed. See the [Combining values section](#combining) and the help page of `combineScores`.

## Why do you recommend using the max method to combine similarities scores for pathways?
The purpose of combining the scores is usually to know which genes or which relationships between pathways are more relevant. The higher the similarity is between two pathway of two genes, the higher functionalities do the genes share, so even if those genes could be less related, this value would be the maximum functional relationship between them. 

## How to detect which functional relationship is more important between two genes?
To detect which relationship is more important between two genes one could either measure other similarities scores or check the stechiometric of the pathways and measure the expression changes and correlation between them.

## How to detect with which genes is my gene of interest related?
You can measure the [gene similarity](#geneSim) between those genes and also measure the expression correlation of your gene of interest with other genes. 

## Why isn't available a method for calculating GO similarities?
This is covered by the `r BiocStyle::Biocpkg("GOSemSim")` package, you can use it to produce a similarity matrix (i.e. use `mgeneSim`). You can parallelize it with `foreach` package or `BiocParallel` if your list of genes is big. 

## How does bioCor deal when one gene is mapped to several ones?
It keeps the one with the higher mean similarity for all the genes available in the comparison. That means that for a different comparison depending on which genes you are computing a gene can have different values. 

# Session Info {.unnumbered}

```{r session}
sessionInfo()
```
